// Parameters:

uniform extern texture LeftEye;  // Left eye texture.
uniform extern texture RightEye; // Right eye texture.

uniform extern float4 LeftEyeColour;  // Left eye colour when using anaglyphs.
uniform extern float4 RightEyeColour; // Right eye colour when using anaglyphs.

uniform extern float ViewportWidth;  // Width of the viewport in pixels.
uniform extern float ViewportHeight; // Height of the viewport in pixels.

// Types:

struct VertexPositionTexture {
    float4 Position : POSITION0;
    float4 Texture : TEXCOORD0;
};

// Texture samplers:

sampler LeftEyeSampler = sampler_state {
	texture = <LeftEye>;
	addressu = CLAMP;
	addressv = CLAMP;
};

sampler RightEyeSampler = sampler_state {
	texture = <RightEye>;
	addressu = CLAMP;
	addressv = CLAMP;
};

// Vertex shaders:

VertexPositionTexture VertexShaderFunction(VertexPositionTexture input) {
    return input;
}

// Pixel shaders:

float4 LeftEyeOnlyPixelShader(VertexPositionTexture input) : COLOR0 {
	return tex2D(LeftEyeSampler, input.Texture);
}

float4 RightEyeOnlyPixelShader(VertexPositionTexture input) : COLOR0 {
	return tex2D(RightEyeSampler, input.Texture);
}

float4 RowInterleavedPixelShader(VertexPositionTexture input) : COLOR0 {
	float row = input.Texture.y * ViewportHeight * 0.5f;
	if (abs(round(row) - row) < 0.1f) {
		return tex2D(LeftEyeSampler, input.Texture);
	} else {
		return tex2D(RightEyeSampler, input.Texture);
	}
}

float4 ColumnInterleavedPixelShader(VertexPositionTexture input) : COLOR0 {
	float col = input.Texture.x * ViewportWidth * 0.5f;
	if (abs(round(col) - col) < 0.1f) {
		return tex2D(LeftEyeSampler, input.Texture);
	} else {
		return tex2D(RightEyeSampler, input.Texture);
	}
}

float4 ChequerboardInterleavedPixelShader(VertexPositionTexture input) : COLOR0 {
	float pixel = (input.Texture.x * ViewportWidth + input.Texture.y * ViewportHeight) * 0.5f;
	if (abs(round(pixel) - pixel) < 0.1f) {
		return tex2D(LeftEyeSampler, input.Texture);
	} else {
		return tex2D(RightEyeSampler, input.Texture);
	}
}

float4 ColourAnaglyphPixelShader(VertexPositionTexture input) : COLOR0 {
	return tex2D(LeftEyeSampler, input.Texture) * LeftEyeColour + tex2D(RightEyeSampler, input.Texture) * RightEyeColour;
}

float4 MonochromeAnaglyphPixelShader(VertexPositionTexture input) : COLOR0 {
	float4 rgbToLuma = float4(0.2109375f, 0.71484375f, 0.07421875f, 0.0f);
	return dot(rgbToLuma, tex2D(LeftEyeSampler, input.Texture)) * LeftEyeColour + dot(rgbToLuma, tex2D(RightEyeSampler, input.Texture)) * RightEyeColour;
}

// Techniques:

technique LeftEyeOnly {
    pass Pass1 {
        VertexShader = compile vs_1_1 VertexShaderFunction();
        PixelShader = compile ps_2_0 LeftEyeOnlyPixelShader();
    }
}

technique RightEyeOnly {
    pass Pass1 {
        VertexShader = compile vs_1_1 VertexShaderFunction();
        PixelShader = compile ps_2_0 RightEyeOnlyPixelShader();
    }
}

technique RowInterleaved {
    pass Pass1 {
        VertexShader = compile vs_1_1 VertexShaderFunction();
        PixelShader = compile ps_2_0 RowInterleavedPixelShader();
    }
}

technique ColumnInterleaved {
    pass Pass1 {
        VertexShader = compile vs_1_1 VertexShaderFunction();
        PixelShader = compile ps_2_0 ColumnInterleavedPixelShader();
    }
}

technique ChequerboardInterleaved {
    pass Pass1 {
        VertexShader = compile vs_1_1 VertexShaderFunction();
        PixelShader = compile ps_2_0 ChequerboardInterleavedPixelShader();
    }
}

technique ColourAnaglyph {
    pass Pass1 {
        VertexShader = compile vs_1_1 VertexShaderFunction();
        PixelShader = compile ps_2_0 ColourAnaglyphPixelShader();
    }
}

technique MonochromeAnaglyph {
    pass Pass1 {
        VertexShader = compile vs_1_1 VertexShaderFunction();
        PixelShader = compile ps_2_0 MonochromeAnaglyphPixelShader();
    }
}