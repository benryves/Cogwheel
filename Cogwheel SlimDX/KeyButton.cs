using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace CogwheelSlimDX {
	class KeyButton : CheckBox {

		#region Converting Keys into human-readable strings.

		/// <summary>
		/// Retrieves a string that represents the name of a key.
		/// </summary>
		/// <param name="lParam">Specifies the second parameter of the keyboard message (such as <c>WM_KEYDOWN</c>) to be processed.</param>
		/// <param name="lpString">Pointer to a buffer that will receive the key name.</param>
		/// <param name="size">Specifies the maximum length, in TCHAR, of the key name, including the terminating null character. (This parameter should be equal to the size of the buffer pointed to by the lpString parameter).</param>
		/// <returns>The length of the returned string.</returns>
		[DllImport("user32.dll")]
		static extern int GetKeyNameText(int lParam, StringBuilder lpString, int size);

		/// <summary>
		/// Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code.
		/// </summary>
		/// <param name="uCode">Specifies the virtual-key code or scan code for a key. How this value is interpreted depends on the value of the <paramref name="uMapType"/> parameter.</param>
		/// <param name="uMapType">Specifies the translation to perform. The value of this parameter depends on the value of the <paramref name="uCode"/> parameter.</param>
		/// <returns>Either a scan code, a virtual-key code, or a character value, depending on the value of <paramref="uCode"/> and <paramref="uMapType"/>. If there is no translation, the return value is zero.</returns>
		[DllImport("user32.dll")]
		static extern int MapVirtualKey(int uCode, MapVirtualKeyMode uMapType);

		enum MapVirtualKeyMode {
			/// <summary>uCode is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not distinguish between left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the function returns 0.</summary>
			MAPVK_VK_TO_VSC = 0,
			/// <summary>uCode is a scan code and is translated into a virtual-key code that does not distinguish between left- and right-hand keys. If there is no translation, the function returns 0.</summary>
			MAPVK_VSC_TO_VK = 1,
			/// <summary>uCode is a virtual-key code and is translated into an unshifted character value in the low-order word of the return value. Dead keys (diacritics) are indicated by setting the top bit of the return value. If there is no translation, the function returns 0.</summary>
			MAPVK_VK_TO_CHAR = 2,
			/// <summary>uCode is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand keys. If there is no translation, the function returns 0.</summary>
			MAPVK_VSC_TO_VK_EX = 3,
			MAPVK_VK_TO_VSC_EX = 4,
		}

		/// <summary>
		/// Converts a <see cref="Keys"/> value into a human-readable string describing the key.
		/// </summary>
		/// <param name="key">The <see cref="Keys"/> to convert.</param>
		/// <returns>A human-readable string describing the key.</returns>
		private static string GetKeyName(Keys key) {

			// Convert the virtual key code into a scancode (as required by GetKeyNameText).
			int Scancode = MapVirtualKey((int)key, MapVirtualKeyMode.MAPVK_VK_TO_VSC);

			// If that returned 0 (failure) just use the value returned by Keys.ToString().
			if (Scancode == 0) return key.ToString();

			// Certain keys end up being mapped to the number pad by the above function,
			// as their virtual key can be generated by the number pad too.
			// If it's one of the known number-pad duplicates, set the extended bit:
			switch (key) {
				case Keys.Insert:
				case Keys.Delete:
				case Keys.Home:
				case Keys.End:
				case Keys.PageUp:
				case Keys.PageDown:
				case Keys.Left:
				case Keys.Right:
				case Keys.Up:
				case Keys.Down:
				case Keys.NumLock:
					Scancode |= 0x100;
					break;
			}

			// Perform the conversion:
			StringBuilder KeyName = new StringBuilder("".PadRight(32));
			if (GetKeyNameText((Scancode << 16), KeyName, KeyName.Length) != 0) {
				return KeyName.ToString();
			} else {
				return key.ToString();
			}
		}

		#endregion

		private ContextMenu JoystickTriggerOptions;

		public enum InputMode {
			Keyboard,
			Joystick,
		}

		public JoystickInputSource JoystickSource { get; set; }

		public event EventHandler SettingChanged;
		protected virtual void OnSettingChanged(EventArgs e) {
			if (this.SettingChanged != null) this.SettingChanged(this, e);
		}
		

		private InputMode mode = InputMode.Keyboard;
		public InputMode Mode {
			get { return this.mode; }
			set { this.mode = value; this.UpdateText(); }
		}

		private void UpdateText() {
			switch (this.Mode) {
				case InputMode.Keyboard:
					base.Text = GetKeyName(this.Key);
					break;
				case InputMode.Joystick:
					base.Text = JoystickTriggerToString(this.JoystickTrigger);
					break;
			}
		}

		private Keys key;
		public Keys Key {
			get { return this.key; }
			set { this.key = value;  this.UpdateText();}
		}

		private JoystickInputSource.InputTrigger trigger;
		public JoystickInputSource.InputTrigger JoystickTrigger {
			get { return this.trigger; }
			set { this.trigger = value; this.UpdateText(); }
		}

		public override string Text {
			get {
				return base.Text;
			}
			set { }
		}

		public KeyButton() {
			this.Key = Keys.None;
			this.JoystickTrigger = JoystickInputSource.InputTrigger.None;
			this.Mode = InputMode.Keyboard;
			this.Appearance = Appearance.Button;
			this.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			this.AutoCheck = false;
			this.JoystickTriggerOptions = new ContextMenu();
		}

		protected override void OnLostFocus(System.EventArgs e) {
			this.Checked = false;
			base.OnLostFocus(e);
		}

		protected override void OnLeave(EventArgs e) {
			this.Checked = false;
			base.OnLeave(e);
		}

		private static string JoystickTriggerToString(JoystickInputSource.InputTrigger trigger) {
			return trigger.ToString().Replace("Button", "Button ").Replace("Axis", "-Axis").Replace("Increase", " Increase").Replace("Decrease", " Decrease");
		}

		protected override void OnMouseDown(MouseEventArgs mevent) {
			switch (mevent.Button) {
				case MouseButtons.Left:
					
					this.Checked ^= true;

					if (this.Checked && this.Mode == InputMode.Joystick) {

						this.Checked = false;

						var ToDispose = new List<MenuItem>();
						foreach (MenuItem OldItem in this.JoystickTriggerOptions.MenuItems) ToDispose.Add(OldItem);

						foreach (var OldItem in ToDispose) {
							this.JoystickTriggerOptions.MenuItems.Remove(OldItem);
							OldItem.Dispose();
						}

						if (this.JoystickSource != null) {
							foreach (JoystickInputSource.InputTrigger Trigger in Enum.GetValues(typeof(JoystickInputSource.InputTrigger))) {
								if (Trigger ==  JoystickInputSource.InputTrigger.None || JoystickSource.SupportsTrigger(Trigger)) {
									this.JoystickTriggerOptions.MenuItems.Add(new MenuItem(
										JoystickTriggerToString(Trigger),
										(sender, e) => { this.JoystickTrigger = (JoystickInputSource.InputTrigger)((MenuItem)sender).Tag; this.OnSettingChanged(new EventArgs()); }
									) {
										Checked = Trigger == this.JoystickTrigger,
										RadioCheck = true,
										Tag = Trigger
									});
								}
							}
						}

						this.JoystickTriggerOptions.Show(this, new Point(0, this.ClientSize.Height));
					}
					break;
				case MouseButtons.Right:
					this.Checked = false;
					this.Key = Keys.None;
					this.JoystickTrigger = JoystickInputSource.InputTrigger.None;
					this.OnSettingChanged(new EventArgs());
					break;
			}
		}

		protected override bool IsInputKey(Keys keyData) {
			return this.Checked;
		}

		protected override void OnKeyDown(KeyEventArgs e) {
			if (this.Checked) {
				e.Handled = true;
				this.Key = e.KeyCode;
				this.Checked = false;
				this.OnSettingChanged(new EventArgs());
			}
			base.OnKeyDown(e);
		}


	}
}
